function [out]=irisrecognition()

%--------------------------------------------------------------------
clc;
chos=0;
possibility=8;
% Finger Recognition Parameters
scales = 1;


messaggio='Insert the number of class: each class determins a person. The ID number is a progressive, integer number. Each class should include a number of images for each person.';

while chos~=possibility,
    chos=menu('Iris Recognition System','Open Camera','Take Photo to database','Database Info','Iris Recognition','Delete Database','Program info',...
        'Source code for Iris Recognition System','Exit');
    %----------------
    if chos==1,
        clc;
        
        cam=webcam(1);
        preview(cam);
        
        pause;
        
        imwrite(rgb2gray(snapshot(cam)), 'your.png');
        
        delete(cam);
        close all;

        
        [namefile,pathname]=uigetfile('your.png','Select image');
        if namefile~=0
            [img,map]=imread(strcat(pathname,namefile));
            imshow(img);
            dimensioni = size(img);
        else
            warndlg('Input image must be selected.',' Warning ')
        end
        disp('An image has just been selected. Now you can add it to database (click on "Add selected image to database")');
        disp('or perform iris recognition (click on "Iris Recognition")');
        
    end
    %----------------
    if chos==2,
        clc;     
        if exist('img')
            if (exist('iris_database.dat')==2)
                load('iris_database.dat','-mat');
                face_number=face_number+1;
                data{face_number,1}=double(img);
                %sprintf('%s','hello',' ','ciao') 
                prompt={sprintf('%s',messaggio,'Class number must be a positive integer <= ',num2str(max_class))};
                title='Class number';
                lines=1;
                def={'1'};
                answer=inputdlg(prompt,title,lines,def);
                zparameter=double(str2num(char(answer)));
                if size(zparameter,1)~=0
                    class_number=zparameter(1);
                    if (class_number<=0)||(class_number>max_class)||(floor(class_number)~=class_number)||(~isa(class_number,'double'))||(any(any(imag(class_number))))
                        warndlg(sprintf('%s','Class number must be a positive integer <= ',num2str(max_class)),' Warning ')
                    else
                        disp('Features extraction...please wait');
                        if class_number==max_class;
                            % this person (class) has never been added to
                            % database before this moment
                            max_class = class_number+1;
                            features  = findfeatures(img,scales);
                        else
                            % this person (class) has already been added to
                            % database
                            features  = findfeatures(img,scales);
                        end


                        data{face_number,2} = class_number;
                        %                         L = length(features);
                        %                         for ii=1:L
                        %                             features_data{features_size+ii,1} = features{ii};
                        %                             features_data{features_size+ii,2} = class_number;
                        %                         end
                        %                         features_size = length(features_data);
                        features_data{features_size+1,1} = features;
                        features_data{features_size+1,2} = class_number;
                        features_data{features_size+1,3} = strcat(pathname,namefile);
                        features_size                    = size(features_data,1);
                        clc;
                        save('iris_database.dat','data','face_number','max_class','features_data','features_size','-append');
                        msgbox(sprintf('%s','Database already exists: image succesfully added to class number ',num2str(class_number)),'Database result','help');
                        close all;
                        clear('img');
                        clc;
                        disp('Iris image added to database.');
                        messaggio2 = sprintf('%s','Location: ',strcat(pathname,namefile));
                        disp(messaggio2);
                        messaggio2 = sprintf('%s','Iris ID: ',num2str(class_number));
                        disp(messaggio2);
                        disp(data);
                        disp(face_number);
                        disp(max_class);
                        disp(features_data);
                        disp(features_size);
                    end
                else
                    warndlg(sprintf('%s','Class number must be a positive integer <= ',num2str(max_class)),' Warning ')
                end
            else
                face_number=1;
                max_class=1;
                data{face_number,1}=double(img);
                prompt={sprintf('%s',messaggio,'Class number must be a positive integer <= ',num2str(max_class))};
                title='Class number';
                lines=1;
                def={'1'};
                answer=inputdlg(prompt,title,lines,def);
                zparameter=double(str2num(char(answer)));
                if size(zparameter,1)~=0
                    class_number=zparameter(1);
                    if (class_number<=0)||(class_number>max_class)||(floor(class_number)~=class_number)||(~isa(class_number,'double'))||(any(any(imag(class_number))))
                        warndlg(sprintf('%s','Class number must be a positive integer <= ',num2str(max_class)),' Warning ')
                    else
                        disp('Features extraction...please wait');
                        max_class=2;
                        data{face_number,2}=class_number;
                        features  = findfeatures(img,scales);
                        disp('Completed.');
                        %                         L = length(features);
                        %                         for ii=1:L
                        %                             features_data{ii,1} = features{ii};
                        %                             features_data{ii,2} = class_number;
                        %                         end
                        features_data{1,1} = features;
                        features_data{1,2} = class_number;
                        features_data{1,3} = strcat(pathname,namefile);
                        features_size = size(features_data,1);
                        save('iris_database.dat','data','face_number','max_class','features_data','features_size');
                        msgbox(sprintf('%s','Database was empty. Database has just been created. Image succesfully added to class number ',num2str(class_number)),'Database result','help');
                        clc;
                        close all;
                        clear('img');
                        disp('Iris image added to database.');
                        messaggio2 = sprintf('%s','Location: ',strcat(pathname,namefile));
                        disp(messaggio2);
                        messaggio2 = sprintf('%s','Iris ID: ',num2str(class_number));
                        disp(messaggio2);
                    end
                else
                    warndlg(sprintf('%s','Class number must be a positive integer <= ',num2str(max_class)),' Warning ')
                end

            end
        else
            errordlg('No image has been selected.','File Error');
        end
    end
    %----------------
    if chos==3,
        clc;
        close all;
        clear('img');
        if (exist('iris_database.dat')==2)
            load('iris_database.dat','-mat');
            msgbox(sprintf('%s','Database has ',num2str(face_number),' image(s). There are',num2str(max_class-1),' class(es). Input images must have the same size.'),'Database result','help');
            disp('Iris images present in database:');
            disp('---');
            for ii=1:features_size
                messaggio2 = sprintf('%s','Location: ',features_data{ii,3});%,' ID: ',num2str(features_data{ii,2}));
                disp(messaggio2);
                messaggio2 = sprintf('%s','Iris ID: ',num2str(features_data{ii,2}));
                disp(messaggio2);
                disp('---');
            end
        else
            msgbox('Database is empty.','Database result','help');
        end
    end
    %----------------
    if chos==4,
        clc;
        close all;
        if exist('img')

            if (exist('iris_database.dat')==2)
                load('iris_database.dat','-mat');
                disp('Features extraction for iris recognition...please wait');
                % code for iris recognition
                features  = findfeatures(img,scales);
                %                 L = length(features);
                %                 score = zeros(max_class-1,1);
                %                 for ii=1:L
                %                     pesi = zeros(features_size,1);
                %                     for jj=1:features_size
                %                         pesi(jj)=norm(features{ii}-features_data{jj,1});
                %                     end
                %                     [val,pos]=min(pesi);
                %                     trovato = features_data{pos,2};
                %                     score(trovato)=score(trovato)+1;
                %                 end
                %                 [val,pos]=max(score);
                messaggio2 = sprintf('%s','Input iris image: ',strcat(pathname,namefile));
                disp(messaggio2);
                disp('---');
                pesi = zeros(features_size,1);
                for ii=1:features_size
                    messaggio2 = sprintf('%s','Current scanned iris image:',features_data{ii,3},' ID: ',num2str(features_data{ii,2}));
                    disp(messaggio2);
                    % hd = gethammingdistance(template1, mask1, template2,mask2, scales)
                    template1 = features{1};
                    mask1     = features{2};
                    template2 = features_data{ii,1}{1};
                    mask2     = features_data{ii,1}{2};
                    pesi(ii)  = gethammingdistance(template1, mask1, template2,mask2, scales);
                end
                [val,pos] = min(pesi);
                pos       = features_data{pos,2};
                disp('---');
                messaggio2 = sprintf('%s','Recognized iris image: ',features_data{pos,3});
                disp(messaggio2);
                disp('Recognized ID');
                disp(pos);
                disp(pesi);
            else
                warndlg('No image processing is possible. Database is empty.',' Warning ')
            end
        else
            warndlg('Input image must be selected.',' Warning ')
        end
    end
    %----------------
    if chos==5,
        clc;
        close all;
        if (exist('iris_database.dat')==2)
            button = questdlg('Do you really want to remove the Database?');
            if strcmp(button,'Yes')
                delete('iris_database.dat');
                clear('data','face_number','max_class','features_data','features_size');
                msgbox('Database was succesfully removed from the current directory.','Database removed','help');
            end
        else
            warndlg('Database is empty.',' Warning ')
        end
    end
    %----------------
    if chos==6,
        clc;
        close all;
        helpwin readme;
    end
    %----------------
    %     if chos==7,
    %         clc;
    %         close all;
    %         if (exist('face_database.dat')==2)
    %             load('face_database.dat','-mat');
    %             % visualization
    %
    %         else
    %             warndlg('Database is empty.',' Warning ');
    %         end
    %     end
    %----------------
    if chos==7,
        clc;
        close all;
        web http://google.com
        helpwin sourcecode;
    end
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function h = addcircle(h, c, radius, weight)

[hr, hc] = size(h);

if nargin == 3
    weight = 1;
end

% c and radius must be integers
if any(c-fix(c))
    error('Circle centre must be in integer coordinates');
end

if radius-fix(radius)
    error('Radius must be an integer');
end

x = 0:fix(radius/sqrt(2));
costheta = sqrt(1 - (x.^2 / radius^2));
y = round(radius*costheta);

% Now fill in the 8-way symmetric points on a circle given coords
% [px py] of a point on the circle.

px = c(2) + [x  y  y  x -x -y -y -x];
py = c(1) + [y  x -x -y -y -x  x  y];

% Cull points that are outside limits
validx = px>=1 & px<=hr;
validy = py>=1 & py<=hc;
valid = find(validx & validy);

px = px(valid);
py = py(valid);

ind = px+(py-1)*hr;
h(ind) = h(ind) + weight;
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function newim = adjgamma(im, g)

if g <= 0
    error('Gamma value must be > 0');
end

if isa(im,'uint8');
    newim = double(im);
else
    newim = im;
end

% rescale range 0-1
newim = newim-min(min(newim));
newim = newim./max(max(newim));

newim =  newim.^(1/g);   % Apply gamma function
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [gradient, or] = canny(im, sigma, scaling, vert, horz)

xscaling = vert;
yscaling = horz;

hsize = [6*sigma+1, 6*sigma+1];   % The filter size.

gaussian = fspecial('gaussian',hsize,sigma);
im = filter2(gaussian,im);        % Smoothed image.

im = imresize(im, scaling);

[rows, cols] = size(im);

h =  [  im(:,2:cols)  zeros(rows,1) ] - [  zeros(rows,1)  im(:,1:cols-1)  ];
v =  [  im(2:rows,:); zeros(1,cols) ] - [  zeros(1,cols); im(1:rows-1,:)  ];
d1 = [  im(2:rows,2:cols) zeros(rows-1,1); zeros(1,cols) ] - ...
    [ zeros(1,cols); zeros(rows-1,1) im(1:rows-1,1:cols-1)  ];
d2 = [  zeros(1,cols); im(1:rows-1,2:cols) zeros(rows-1,1);  ] - ...
    [ zeros(rows-1,1) im(2:rows,1:cols-1); zeros(1,cols)   ];

X = ( h + (d1 + d2)/2.0 ) * xscaling;
Y = ( v + (d1 - d2)/2.0 ) * yscaling;

gradient = sqrt(X.*X + Y.*Y); % Gradient amplitude.

or = atan2(-Y, X);            % Angles -pi to + pi.
neg = or<0;                   % Map angles to 0-pi.
or = or.*~neg + (or+pi).*neg;
or = or*180/pi;               % Convert to degrees.
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [x,y] = circlecoords(c, r, imgsize,nsides)


if nargin == 3
    nsides = 600;
end

nsides = round(nsides);

a = [0:pi/nsides:2*pi];
xd = (double(r)*cos(a)+ double(c(1)) );
yd = (double(r)*sin(a)+ double(c(2)) );

xd = round(xd);
yd = round(yd);

%get rid of -ves
%get rid of values larger than image
xd2 = xd;
coords = find(xd>imgsize(2));
xd2(coords) = imgsize(2);
coords = find(xd<=0);
xd2(coords) = 1;

yd2 = yd;
coords = find(yd>imgsize(1));
yd2(coords) = imgsize(1);
coords = find(yd<=0);
yd2(coords) = 1;

x = int32(xd2);
y = int32(yd2);
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [template, mask] = encode(polar_array,noise_array, nscales, minWaveLength, mult, sigmaOnf)

% convolve normalised region with Gabor filters
[E0 filtersum] = gaborconvolve(polar_array, nscales, minWaveLength, mult, sigmaOnf);

length = size(polar_array,2)*2*nscales;

template = zeros(size(polar_array,1), length);

length2 = size(polar_array,2);
h = 1:size(polar_array,1);

%create the iris template

mask = zeros(size(template));

for k=1:nscales

    E1 = E0{k};

    %Phase quantisation
    H1 = real(E1) > 0;
    H2 = imag(E1) > 0;

    % if amplitude is close to zero then
    % phase data is not useful, so mark off
    % in the noise mask
    H3 = abs(E1) < 0.0001;


    for i=0:(length2-1)

        ja = double(2*nscales*(i));
        %construct the biometric template
        template(h,ja+(2*k)-1) = H1(h, i+1);
        template(h,ja+(2*k)) = H2(h,i+1);

        %create noise mask
        mask(h,ja+(2*k)-1) = noise_array(h, i+1) | H3(h, i+1);
        mask(h,ja+(2*k)) =   noise_array(h, i+1) | H3(h, i+1);

    end

end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [row, col, r] = findcircle(image,lradius,uradius,scaling, sigma, hithres, lowthres, vert, horz)

lradsc = round(lradius*scaling);
uradsc = round(uradius*scaling);
rd = round(uradius*scaling - lradius*scaling);

% generate the edge image
[I2 or] = canny(image, sigma, scaling, vert, horz);
I3 = adjgamma(I2, 1.9);
I4 = nonmaxsup(I3, or, 1.5);
edgeimage = hysthresh(I4, hithres, lowthres);

% perform the circular Hough transform
h = houghcircle(edgeimage, lradsc, uradsc);

maxtotal = 0;

% find the maximum in the Hough space, and hence
% the parameters of the circle
for i=1:rd

    layer = h(:,:,i);
    [maxlayer] = max(max(layer));


    if maxlayer > maxtotal

        maxtotal = maxlayer;


        r = int32((lradsc+i) / scaling);

        [row,col] = ( find(layer == maxlayer) );


        row = int32(row(1) / scaling); % returns only first max value
        col = int32(col(1) / scaling);

    end

end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function lines = findline(image)

[I2 or] = canny(image, 2, 1, 0.00, 1.00);

I3 = adjgamma(I2, 1.9);
I4 = nonmaxsup(I3, or, 1.5);
edgeimage = hysthresh(I4, 0.20, 0.15);


theta = (0:179)';
[R, xp] = radon(edgeimage, theta);

maxv = max(max(R));

if maxv > 25
    i = find(R == max(max(R)));
else
    lines = [];
    return;
end

[foo, ind] = sort(-R(i));
u = size(i,1);
k = i(ind(1:u));
[y,x]=ind2sub(size(R),k);
t = -theta(x)*pi/180;
r = xp(y);

lines = [cos(t) sin(t) -r];

cx = size(image,2)/2-1;
cy = size(image,1)/2-1;
lines(:,3) = lines(:,3) - lines(:,1)*cx - lines(:,2)*cy;
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [EO, filtersum] = gaborconvolve(im, nscale, minWaveLength, mult, ...
    sigmaOnf)

[rows cols] = size(im);
filtersum = zeros(1,size(im,2));

EO = cell(1, nscale);          % Pre-allocate cell array

ndata = cols;
if mod(ndata,2) == 1             % If there is an odd No of data points
    ndata = ndata-1;               % throw away the last one.
end

logGabor  = zeros(1,ndata);
result = zeros(rows,ndata);

radius =  [0:fix(ndata/2)]/fix(ndata/2)/2;  % Frequency values 0 - 0.5
radius(1) = 1;

wavelength = minWaveLength;        % Initialize filter wavelength.


for s = 1:nscale,                  % For each scale.

    % Construct the filter - first calculate the radial filter component.
    fo = 1.0/wavelength;                  % Centre frequency of filter.
    rfo = fo/0.5;                         % Normalised radius from centre of frequency plane
    % corresponding to fo.
    logGabor(1:ndata/2+1) = exp((-(log(radius/fo)).^2) / (2 * log(sigmaOnf)^2));
    logGabor(1) = 0;

    filter = logGabor;

    filtersum = filtersum+filter;

    % for each row of the input image, do the convolution, back transform
    for r = 1:rows	% For each row

        signal = im(r,1:ndata);


        imagefft = fft( signal );


        result(r,:) = ifft(imagefft .* filter);

    end

    % save the ouput for each scale
    EO{s} = result;

    wavelength = wavelength * mult;       % Finally calculate Wavelength of next filter
end                                     % ... and process the next scale

filtersum = fftshift(filtersum);

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function h = houghcircle(edgeim, rmin, rmax)
 [rows,cols] = size(edgeim);
 nradii = rmax-rmin+1;
 h = zeros(rows,cols,nradii);
 
 
 [y,x] = find(edgeim~=0);
 
 hr     = rows;
 hc     = cols;
 hrhc   = hr*hc;
 weight = 1;
 
 %for each edge point, draw circles of different radii
 for index=1:size(y)
 
     cx = x(index);
     cy = y(index);
     
     c  = [cx,cy];
 
     for n=1:nradii
 
         
         radius   = n+rmin;
         xd       = 0:fix(radius/sqrt(2));
         costheta = sqrt(1-(xd.^2/radius^2));
         yd       = round(radius*costheta);
         px       = c(2) + [xd  yd  yd  xd -xd -yd -yd -xd];
         py       = c(1) + [yd  xd -xd -yd -yd -xd  xd  yd];
         validx   = px>=1 & px<=hr;
         validy   = py>=1 & py<=hc;
         valid    = find(validx & validy);
         px       = px(valid);
         py       = py(valid);
         ind      = px+(py-1)*hr;
         
         positions    = ind+(n-1)*hrhc;
         h(positions) = h(positions)+ weight;
         % h(ind+(n-1)*hr*hc) = h(ind+(n-1)*hr*hc)+ weight;
     end
 
 end

function bw = hysthresh(im, T1, T2)

if (T2 > T1 | T2 < 0 | T1 < 0)  % Check thesholds are sensible
    error('T1 must be >= T2 and both must be >= 0 ');
end

[rows, cols] = size(im);    % Precompute some values for speed and convenience.
rc = rows*cols;
rcmr = rc - rows;
rp1 = rows+1;

bw = im(:);                 % Make image into a column vector
pix = find(bw > T1);        % Find indices of all pixels with value > T1
npix = size(pix,1);         % Find the number of pixels with value > T1

stack = zeros(rows*cols,1); % Create a stack array (that should never
% overflow!)

stack(1:npix) = pix;        % Put all the edge points on the stack
stp = npix;                 % set stack pointer
for k = 1:npix
    bw(pix(k)) = -1;        % mark points as edges
end


% Precompute an array, O, of index offset values that correspond to the eight
% surrounding pixels of any point. Note that the image was transformed into
% a column vector, so if we reshape the image back to a square the indices
% surrounding a pixel with index, n, will be:
%              n-rows-1   n-1   n+rows-1
%
%               n-rows     n     n+rows
%
%              n-rows+1   n+1   n+rows+1

O = [-1, 1, -rows-1, -rows, -rows+1, rows-1, rows, rows+1];

while stp ~= 0            % While the stack is not empty
    v = stack(stp);         % Pop next index off the stack
    stp = stp - 1;

    if v > rp1 && v < rcmr   % Prevent us from generating illegal indices
        % Now look at surrounding pixels to see if they
        % should be pushed onto the stack to be
        % processed as well.
        index = O+v;	    % Calculate indices of points around this pixel.
        for l = 1:8
            ind = index(l);
            if bw(ind) > T2   % if value > T2,
                stp = stp+1;  % push index onto the stack.
                stack(stp) = ind;
                bw(ind) = -1; % mark this as an edge point
            end
        end
    end
end



bw = (bw == -1);            % Finally zero out anything that was not an edge
bw = reshape(bw,rows,cols); % and reshape the image
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [x,y] = linecoords(lines, imsize)

xd = [1:imsize(2)];
yd = (-lines(3) - lines(1)*xd ) / lines(2);

coords = find(yd>imsize(1));
yd(coords) = imsize(1);
coords = find(yd<1);
yd(coords) = 1;

x = int32(xd);
y = int32(yd);
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function im = nonmaxsup(inimage, orient, radius)

if size(inimage) ~= size(orient)
    error('image and orientation image are of different sizes');
end

if radius < 1
    error('radius must be >= 1');
end

[rows,cols] = size(inimage);
im = zeros(rows,cols);        % Preallocate memory for output image for speed
iradius = ceil(radius);

% Precalculate x and y offsets relative to centre pixel for each orientation angle

angle = [0:180].*pi/180;    % Array of angles in 1 degree increments (but in radians).
xoff = radius*cos(angle);   % x and y offset of points at specified radius and angle
yoff = radius*sin(angle);   % from each reference position.

hfrac = xoff - floor(xoff); % Fractional offset of xoff relative to integer location
vfrac = yoff - floor(yoff); % Fractional offset of yoff relative to integer location

orient = fix(orient)+1;     % Orientations start at 0 degrees but arrays start
% with index 1.

% Now run through the image interpolating grey values on each side
% of the centre pixel to be used for the non-maximal suppression.

for row = (iradius+1):(rows - iradius)
    for col = (iradius+1):(cols - iradius)

        or = orient(row,col);   % Index into precomputed arrays

        x = col + xoff(or);     % x, y location on one side of the point in question
        y = row - yoff(or);

        fx = floor(x);          % Get integer pixel locations that surround location x,y
        cx = ceil(x);
        fy = floor(y);
        cy = ceil(y);
        tl = inimage(fy,fx);    % Value at top left integer pixel location.
        tr = inimage(fy,cx);    % top right
        bl = inimage(cy,fx);    % bottom left
        br = inimage(cy,cx);    % bottom right

        upperavg = tl + hfrac(or) * (tr - tl);  % Now use bilinear interpolation to
        loweravg = bl + hfrac(or) * (br - bl);  % estimate value at x,y
        v1 = upperavg + vfrac(or) * (loweravg - upperavg);

        if inimage(row, col) > v1 % We need to check the value on the other side...

            x = col - xoff(or);     % x, y location on the `other side' of the point in question
            y = row + yoff(or);

            fx = floor(x);
            cx = ceil(x);
            fy = floor(y);
            cy = ceil(y);
            tl = inimage(fy,fx);    % Value at top left integer pixel location.
            tr = inimage(fy,cx);    % top right
            bl = inimage(cy,fx);    % bottom left
            br = inimage(cy,cx);    % bottom right
            upperavg = tl + hfrac(or) * (tr - tl);
            loweravg = bl + hfrac(or) * (br - bl);
            v2 = upperavg + vfrac(or) * (loweravg - upperavg);

            if inimage(row,col) > v2            % This is a local maximum.
                im(row, col) = inimage(row, col); % Record value in the output image.
            end

        end
    end
end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [polar_array, polar_noise] = normaliseiris(image, x_iris, y_iris, r_iris,...
    x_pupil, y_pupil, r_pupil, radpixels, angulardiv)

% global DIAGPATH

radiuspixels = radpixels + 2;
angledivisions = angulardiv-1;

r = 0:(radiuspixels-1);

theta = 0:2*pi/angledivisions:2*pi;

x_iris = double(x_iris);
y_iris = double(y_iris);
r_iris = double(r_iris);

x_pupil = double(x_pupil);
y_pupil = double(y_pupil);
r_pupil = double(r_pupil);

% calculate displacement of pupil center from the iris center
ox = x_pupil - x_iris;
oy = y_pupil - y_iris;

if ox <= 0
    sgn = -1;
elseif ox > 0
    sgn = 1;
end

if ox==0 && oy > 0

    sgn = 1;

end

r = double(r);
theta = double(theta);

a = ones(1,angledivisions+1)* (ox^2 + oy^2);

% need to do something for ox = 0
if ox == 0
    phi = pi/2;
else
    phi = atan(oy/ox);
end

b = sgn.*cos(pi - phi - theta);

% calculate radius around the iris as a function of the angle
r = (sqrt(a).*b) + ( sqrt( a.*(b.^2) - (a - (r_iris^2))));

r = r - r_pupil;

rmat = ones(1,radiuspixels)'*r;

rmat = rmat.* (ones(angledivisions+1,1)*[0:1/(radiuspixels-1):1])';
rmat = rmat + r_pupil;


% exclude values at the boundary of the pupil iris border, and the iris scelra border
% as these may not correspond to areas in the iris region and will introduce noise.
%
% ie don't take the outside rings as iris data.
rmat  = rmat(2:(radiuspixels-1), :);

% calculate cartesian location of each data point around the circular iris
% region
xcosmat = ones(radiuspixels-2,1)*cos(theta);
xsinmat = ones(radiuspixels-2,1)*sin(theta);

xo = rmat.*xcosmat;
yo = rmat.*xsinmat;

xo = x_pupil+xo;
yo = y_pupil-yo;

% extract intensity values into the normalised polar representation through
% interpolation
[x,y] = meshgrid(1:size(image,2),1:size(image,1));
polar_array = interp2(x,y,image,xo,yo);

% create noise array with location of NaNs in polar_array
polar_noise = zeros(size(polar_array));
coords = find(isnan(polar_array));
polar_noise(coords) = 1;

polar_array = double(polar_array)./255;


% start diagnostics, writing out eye image with rings overlayed

% get rid of outling points in order to write out the circular pattern
coords = find(xo > size(image,2));
xo(coords) = size(image,2);
coords = find(xo < 1);
xo(coords) = 1;

coords = find(yo > size(image,1));
yo(coords) = size(image,1);
coords = find(yo<1);
yo(coords) = 1;

xo = round(xo);
yo = round(yo);

xo = int32(xo);
yo = int32(yo);

ind1 = sub2ind(size(image),double(yo),double(xo));

image = uint8(image);

image(ind1) = 255;
% get pixel coords for circle around iris
[x,y] = circlecoords([x_iris,y_iris],r_iris,size(image));
ind2 = sub2ind(size(image),double(y),double(x));
% get pixel coords for circle around pupil
[xp,yp] = circlecoords([x_pupil,y_pupil],r_pupil,size(image));
ind1 = sub2ind(size(image),double(yp),double(xp));

image(ind2) = 255;
image(ind1) = 255;


% write out rings overlaying original iris image
%w = cd;
%cd(DIAGPATH);

imwrite(image,'your-normal.jpg','jpg');

%cd(w);

% end diagnostics

%replace NaNs before performing feature encoding
coords = find(isnan(polar_array));
polar_array2 = polar_array;
polar_array2(coords) = 0.5;
avg = sum(sum(polar_array2)) / (size(polar_array,1)*size(polar_array,2));
polar_array(coords) = avg;
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [circleiris, circlepupil, imagewithnoise] = segmentiris(eyeimage)

scale=0.8;
tic

rmin=rmin*scale;
rmax=rmax*scale;
%scales all the parameters to the required scale
I=im2double(I);
%arithmetic operations are not defined on uint8
%hence the image is converted to double
pimage=I;
%stores the image for display
I=imresize(I,scale);
I=imcomplement(imfill(imcomplement(I),'holes'));
%this process removes specular reflections by using the morphological operation 'imfill'

rows=size(I,1);
cols=size(I,2);
[X,Y]=find(I<0.5);
%Generates a column vector of the image elements
%that have been selected by tresholding;one for x coordinate and one for y
s=size(X,1);
for k=1:s %
    if (X(k)>rmin)&(Y(k)>rmin)&(X(k)<=(rows-rmin))&(Y(k)<(cols-rmin))
        A=I((X(k)-1):(X(k)+1),(Y(k)-1):(Y(k)+1));
        M=min(min(A));
        %this process scans the neighbourhood of the selected pixel
        %to check if it is a local minimum
        if I(X(k),Y(k))~=M
            X(k)=NaN;
            Y(k)=NaN;
        end
    end
end
v=find(isnan(X));
X(v)=[];
Y(v)=[];
%deletes all pixels that are NOT local minima(that have been set to NaN)
index=find((X<=rmin)|(Y<=rmin)|(X>(rows-rmin))|(Y>(cols-rmin)));
X(index)=[];
Y(index)=[];
%This process deletes all pixels that are so close to the border
%that they could not possibly be the centre coordinates.
N=size(X,1);
%recompute the size after deleting unnecessary elements
maxb=zeros(rows,cols);
maxrad=zeros(rows,cols);
%defines two arrays maxb and maxrad to store the maximum value of blur
%for each of the selected centre points and the corresponding radius
for j=1:N
    [b,r,blur]=partiald(I,[X(j),Y(j)],rmin,rmax,'inf',600,'iris');%coarse search
    maxb(X(j),Y(j))=b;
    maxrad(X(j),Y(j))=r;
end
[x,y]=find(maxb==max(max(maxb)));
ci=search(I,rmin,rmax,x,y,'iris');%fine search
%finds the maximum value of blur by scanning all the centre coordinates
ci=ci/scale;
%the function search searches for the centre of the pupil and its radius
%by scanning a 10*10 window around the iris centre for establishing
%the pupil's centre and hence its radius
cp=search(I,round(0.1*r),round(0.8*r),ci(1)*scale,ci(2)*scale,'pupil');%Ref:Daugman's paper that sets biological limits on the relative sizes of the iris and pupil
cp=cp/scale;
%displaying the segmented image
out=drawcircle(pimage,[ci(1),ci(2)],ci(3),600);
out=drawcircle(out,[cp(1),cp(2)],cp(3),600);
time=toc;














end

%For CASIA, eliminate eyelashes by thresholding
ref = eyeimage < 100;
coords = find(ref==1);
imagewithnoise(coords) = NaN;
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function templatenew = shiftbits(template, noshifts,nscales)

templatenew = zeros(size(template));

width = size(template,2);
s = round(2*nscales*abs(noshifts));
p = round(width-s);

if noshifts == 0
    templatenew = template;

    % if noshifts is negatite then shift towards the left
elseif noshifts < 0

    x=1:p;

    templatenew(:,x) = template(:,s+x);

    x=(p + 1):width;

    templatenew(:,x) = template(:,x-p);

else

    x=(s+1):width;

    templatenew(:,x) = template(:,x-s);

    x=1:s;

    templatenew(:,x) = template(:,p+x);

end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function [out]=findfeatures(eyeimage,scales)
radial_res  = 20;
angular_res = 240;

% with these settings a 9600 bit iris template is
% created

%feature encoding parameters
nscales=scales;
minWaveLength=18;
mult=1; % not applicable if using nscales = 1
sigmaOnf=0.5;

[circleiris circlepupil imagewithnoise] = segmentiris(eyeimage);


imagewithnoise2 = uint8(imagewithnoise);
imagewithcircles = uint8(eyeimage);

%get pixel coords for circle around iris
[x,y] = circlecoords([circleiris(2),circleiris(1)],circleiris(3),size(eyeimage));
ind2 = sub2ind(size(eyeimage),double(y),double(x));

%get pixel coords for circle around pupil
[xp,yp] = circlecoords([circlepupil(2),circlepupil(1)],circlepupil(3),size(eyeimage));
ind1 = sub2ind(size(eyeimage),double(yp),double(xp));


imagewithnoise2(ind2) = 255;
imagewithnoise2(ind1) = 255;
% Write circles overlayed
imagewithcircles(ind2) = 255;
imagewithcircles(ind1) = 255;

[polar_array noise_array] = normaliseiris(imagewithnoise, circleiris(2),...
    circleiris(1), circleiris(3), circlepupil(2), circlepupil(1), circlepupil(3), radial_res, angular_res);


[template mask] = encode(polar_array, noise_array, nscales, minWaveLength, mult, sigmaOnf);
out{1} = template;
out{2} = mask;
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
function hd = gethammingdistance(template1, mask1, template2, mask2, scales)

template1 = logical(template1);
mask1 = logical(mask1);

template2 = logical(template2);
mask2 = logical(mask2);

hd = NaN;

% shift template left and right, use the lowest Hamming distance
for shifts=-8:8

    template1s = shiftbits(template1, shifts,scales);
    mask1s = shiftbits(mask1, shifts,scales);


    mask = mask1s | mask2;

    nummaskbits = sum(sum(mask == 1));

    totalbits = (size(template1s,1)*size(template1s,2)) - nummaskbits;

    C = xor(template1s,template2);

    C = C & ~mask;
    bitsdiff = sum(sum(C==1));

    if totalbits == 0

        hd = NaN;

    else

        hd1 = bitsdiff / totalbits;


        if  hd1 < hd || isnan(hd)

            hd = hd1;

        end


    end

end
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%--------------------------------------------------------------------------


